<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R 활용 서지데이터 네트워크 분석 및 시각화</title>
    <meta charset="utf-8" />
    <meta name="author" content="이준영" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/my_hangul.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# R 활용 서지데이터<br>네트워크 분석 및 시각화
## 🌌
### 이준영
### KISTI, 미래기술분석센터
### 2020년 5월 26-27일

---

background-position: 50% 50%
class: center, bottom
background-image: url("/pic/unnamed-chunk-1-1.png")
background-size: 85%

#### &lt;font color = "steelblue"&gt;COOL!&lt;/font&gt; 

???

Image credit: [Stack Overflow Tag Network](https://juliasilge.com/blog/tag-network/)

---
class: left, top

## 강의를 듣고 나면  


1) 이미 만들어 놓은 '네트워크' 데이터를 이용하는 것에서 벗어나, **네트워크 분석에 
적합한 형태의 데이터**를 직접 생성해낼 수 있다.
 

2) Point &amp; Click 방식의 네트워크 분석도구(Gephi, Pajek, Ucinet 등)에 대한 의존에서 벗어나, 프로그래밍 방식에 의해 **분석의 자유도**를 높일 수 있다. 

![:scale 150%](/pic/data-science-explore.png)

3) 네트워크 분석과 다른 데이터 분석 프로세스 간의 장벽을 허물고, tidygraph, ggraph 등 네트워크 분석 관련 R의 최신 패키지를 활용하여 **통합 프레임**에서 진행할 수 있게 된다.  
 
---
### 분석 환경 준비 

* [R Ver.4.0 base](https://cloud.r-project.org/)
* [RStudio](https://rstudio.com/products/rstudio/download/)
* [Rtools](https://cloud.r-project.org/) : 윈도우(64bit/32bit)에 따른 버전 연동
* Rtools를 깔고 나서 Rstudio에서 아래 명령 실행  

```r
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
```
* 4.0이전의 R 버전이 깔려 있었다면, 아래 명령 실행 

```r
update.packages(ask=FALSE, checkBuilt=TRUE)
```
* 일단 깔아야 할 패키지 

```r
install.packages(c("tidyverse", "data.table", "ggraph", "tidygraph", "gapminder",
                   "Matrix", "tidytext", "text2vec"))
```
---
class: inverse, center, middle

## 네트워크 분석은&lt;br&gt;
## 어떤 점에서&lt;br&gt;
## 특별한가? 

---

## 테이블 데이터 VS 네트워크 데이터 

**전통적인** 테이블 형태의 '깔끔한' 데이터
&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; mpg &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; cyl &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; disp &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; hp &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; drat &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; wt &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; qsec &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; vs &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; am &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; gear &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; carb &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Mazda RX4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 160 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 110 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.90 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.620 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 16.46 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Mazda RX4 Wag &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 160 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 110 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.90 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.875 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 17.02 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Datsun 710 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 22.8 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 108 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 93 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.85 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.320 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.61 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Hornet 4 Drive &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 258 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 110 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.08 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.215 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 19.44 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Hornet Sportabout &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.7 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 8 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 360 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 175 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.15 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.440 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 17.02 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Valiant &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 225 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 105 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.76 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.460 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 20.22 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
- 행 = 분석 대상 관측치/관측 개체(**observations**), 

- 열 = 대상에 대한 변수들(**variables/features**) 

그러나, 네트워크 데이터는 이러한 관측 개체의 특성을 정리한 '테이블' 형태도 포함하지만, 관측 개체 간의 **연결(link)**에 대한 정보가 핵심 

- 이 정보를 어떻게 **데이터**에 담고, 담아낸 데이터를 **어떠한 방식**으로 꺼내어 활용할 수 있을까? (🌟강의의 핵심) 


---
## 네트워크 데이터의 구조 

- 개체(nodes, vertices) + 노드 간 연결(edges, links, ties) 

- 그리고 node와 edge 각각에 대해 부여된 다양한 속성(attributes)
![:scale 90%](/pic/network_data_scheme01.png)

---
## 네트워크 데이터의 분해 
- node, edge의 속성들은 네트워크에 독립적인 것(소속 집단, 젠더, 년도 등) + 네트워크에서 추출된 것 (클러스터링 결과 집단, 중앙성 등)으로 구분  

  ![:scale 62%](/pic/network_data_scheme02.png)
---
## 네트워크 데이터의 재결합  

- 노드 + 노드 속성, 에지 + 에지 속성을 각각 **데이터 프레임** 형태로 표현 

- 노드, 에지 각 두 가지 데이터를 결합하여 **네트워크 데이터** 'object'로 관리   
   ![:scale 85%](/pic/network_data_scheme03.png)

---

## 용어 정리 

* 그래프 **G = (V, E)**는  nodes(또는 vertices)의 집합과 해당 노드들 간의 edges(또는 links, ties)의 집합을 의미함. '네트워크'와 혼용. 

* 그래프에서 edges는 **방향성**이 있을 수도(directed), 방향성이 없을 수도(undirected) 있음. 연결 관계가 상호적인지, 일방성을 갖는지에 따른 차이임. 

* Edges나 nodes에는 여러 다양한 맥락에 따라 측정가능한 **가중치**(weight)가 부여될 수 있음.

* **경로(path)**는 두 node 간의 연속적인 edge의 배열임. edge의 배열에서 해당 노드를 통과하는 것은 제외함. 해당 노드가 포함되는 경로는 **walk**라고 함. 두 노드 사이에는 경로가 존재하지 않을 수도 있으며, 최단 경로(shortest path)는 하나 이상 존재하며, 이를 **geodesic**이라고도 함. 최단 경로 길이는 노드 간 거리에 대한 정의에 따라 다를 수 있으나, 대개는 가중치를 고려하지 않으면 경로에 포함된 edge의 갯수로, 가중치를 고려하면 edge들의 가중치 합으로 표시함. 한 그래프에서 모든 노드의 쌍(pair)에 대해 경로가 존재한다면 **연결되었다(connected)**고 함. 

* 방향성이 존재하지 않는 경우, 모든 노드의 쌍에 경로가 존재하는 노들들의 집합을 **컴포넌트(component)** 라고 함. edge의 방향성이 존재하고, 방향성을 고려하여 모든 노드 쌍들의 경로가 존재하는 경우를 **강한 연결 컴포넌트(strongly connected component)**라고 함.

---

## 용어 정리

* 그래프의 **직경(diameter)**은 그래프의 모든 노드 쌍의 최단 경로(geodesic) 중에서 가장 긴 것을 가리킴.  

* 특정 node의 **편심거리(eccentricity)**는 해당 노드에서 시작하는 경로 중 가장 긴 최단 경로임. 편심거리가 낮은 노드는 그래프에서 중심적 위치를 차지하게 됨. 

* v, w라는 두 node로  구성된 edge (v, w)가 존재하면 해당 두 노드는 **인접(adjacent)**되었다고 하며, edge는 node에 연결(incident)되었다고 함. 

* **연결 정도 중심성(degree centrality)**은 그래프에서 해당 노드와 인접한(incident) edge의 개수 

* **매개 중심성(betweenness centrality)**은 전체 node 쌍의 최단 경로(geodesic)의 가짓 수에서 특정 노드를 통과하는 최단 경로의 가짓수의 비율임. 네트워크의 전체 흐름에 대한 통제를 의미   

* **아이겐벡터 중심성(eigenvector centrality)**은 해당 node에 연결된 node들의 중심성들의 합을 반복 계산하여 수렴되는 값으로, 단순히 '많은 연결관계'가 아니라 잘 연결된 노드와의 연결 정도를 나타내어 '위세(prestige)', '지위(prestige)'를 의미

---

## R에서 네트워크 데이터 처리의 역사

- 2000년대 초반에 등장한 [sna](https://cran.r-project.org/web/packages/sna/index.html), 2000년대 중반에 등장한  [igraph](https://igraph.org/r/)는 R 진영에서 사회연결망 분석에 가장 많이 활용된 패키지 

- 그 중에서도 igraph가 처리 속도, 포괄성 등에서 더 우월하여 핵심적인 지위를 차지 

- 그러나 2017년 혜성🌠과 같이 등장한 [tidygraph](https://cran.r-project.org/web/packages/tidygraph/index.html), [ggraph](https://cran.r-project.org/web/packages/ggraph/index.html) 패키지는 **tidyverse**라는 Rstudio 진영의 새로운 R 생태계의 네트워크'버전'을 지향

- 즉, 네트워크 분석을 tidyverse의 전체 데이터 분석 프레임에서 **seamless** 하게 연동 가능

- **tidygraph**는 igraph의 object를 유지(= 아래에 igraph의 엔진 + [netrankr](https://cran.r-project.org/web/packages/netrankr/index.html) 이나 [influenceR](https://cran.r-project.org/web/packages/influenceR/index.html)과 같은 최신 네트워크 분석지표 패키지를 통합하고 tidyverse의 데이터처리 패키지 [dplyr](https://dplyr.tidyverse.org/)의 문법을 그대로 적용가능  

- **ggraph**는 데이터 시각화에서 R의 사실상 표준인 [ggplot2](https://ggplot2.tidyverse.org/)의 문법을 그대로 연동 가능 

- 네트워크 데이터 시각화 관련한 ggplot2의 확장패키지로 [ggnetwork](https://cran.r-project.org/web/packages/ggnetwork/vignettes/ggnetwork.html)이나  [ggnet](https://briatte.github.io/ggnet/) 등도 존재하나 이번 강의에서는 ggraph를 이용 
 

---
### tidyverse에서 tidygraph, ggraph의 통합 연동

  ![scale: 80%](/pic/tidyverse_integrated.png)

---
## 정리 : 데이터에서 "tidy"의 의미 

 앞에서 언급했던 **전통적인 깔끔한 테이블 형태**의 데이터를 의미이며, 세가지 조건을 충족
 
  - 각각의 열(column)은 **변수(variable)**이다
  
  - 각각의 행(row)은 **관측치(observation)**이다

  - 각각의 셀(cell)은 **단일한 값**을 갖는다 

![scale: 80%](/pic/tidy_data_way.png)

 네트워크 데이터에 대해 tidy 원리의 적용은 node에 대해서, edge 에 대해서 **따로** 적용 
   
  - node는 기존의 tidy 원리와 동일하게 적용하며,  
   
  - edge는 node와 node의 쌍(pair)을 관측치로 보고, 이에 대해 tidy 원리를 적용한다는 것     
---
### 네트워크 데이터 생성하기 : 간단한 몸풀기 

node와 edge, directed/undirected 를 그래프 형태로 그리기 

  ![:scale 65%](/pic/terminology_01.png)

node와 edge의 관계를 행렬(Matrix)로 그리기 

  ![:scale 65%](/pic/terminology_02.png)

---
우선 네트워크를 행렬로 표현해 보자. 행과 열이 동일한 undirected 경우에는 아래 두 경우가 동일 
- full matrix인 경우 대칭구조를 가지며, 

```r
M &lt;-  rbind(c(0,1,0,0), c(1,0,1,1), c(0,1,0,1), c(0,1,1,0))
node_name &lt;-  c("A", "B", "C", "D")
dimnames(M) &lt;-  list(node_name, node_name)
M_full &lt;- M
M_full
```

```
##   A B C D
## A 0 1 0 0
## B 1 0 1 1
## C 0 1 0 1
## D 0 1 1 0
```
- upper/lower triangualr matrix인 경우 (아래는 하삼각행렬)  

```r
M[upper.tri(M_full, diag = FALSE)] &lt;- 0
M_lower &lt;- M
M_lower
```

```
##   A B C D
## A 0 0 0 0
## B 1 0 0 0
## C 0 1 0 0
## D 0 1 1 0
```


---
 앞에서 생성한 두 행렬 M_full과 M_lower를 그래프 오브젝트로 만들어보자. 

```r
library(tidygraph)
# tidygraph패키지로 행렬 데이터에서 igraph/tidygraph 오브젝트 생성
*g_full &lt;- as_tbl_graph(M_full, directed = FALSE)
# 일단 igraph의 기본 시각화 도구 이용 
plot(g_full) 
```

![](network_course_part01_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;
---
하삼각행렬도 전체 대칭행렬의 그림과 동일한 것으로 확인 

```r
# 역시 행렬 데이터에서 igraph/tidygraph 오브젝트 생성
*g_lower &lt;- as_tbl_graph(M_lower, directed = FALSE)
plot(g_lower)
```

![](network_course_part01_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;


---
-행렬의 행과 열이 다른 대상인 경우 :
- 즉, 행(row)이 분석하려는 대상이고, 열(column)이 분석대상의 프로파일 벡터의 요소인 경우
  (예, 행이 문서, 열이 참고문헌인 경우 행벡터는 각 문서의 **citing 벡터**)


```r
library(igraph)
A &lt;-  rbind(c(0,1,1,0,0), c(1,1,1,0,0), c(0,0,1,1,1), c(1,0,0,0,1))
doc_name &lt;-  c("D1", "D2", "D3", "D4")
ref_name &lt;- c("R1", "R2", "R3", "R4", "R5")
dimnames(A) &lt;-  list(doc_name, ref_name)
g &lt;- as_tbl_graph(A, directed = TRUE)
par(mar = c(14,2,0,2)) # 슬라이드 편집을 위한 단순 마진 설정
plot(g, layout = layout_as_bipartite) # bipartite 네트워크 레이아웃 
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-8-1.png" width="70%" /&gt;
---
- 이제, 앞에서 생성한 citing profile 벡터 간 **겹칩**의 빈도를 edge의 weight로 하려고 함.
  (이는 뒤에서 살펴볼 **서지결합(bibliographic coupling)** 관계임)
  

```r
# 행렬 A와 전치행렬(transposed) A의 곱이 겹침 빈도를 생성
BC &lt;- A %*% t(A) ; BC
```

```
##    D1 D2 D3 D4
## D1  2  2  1  0
## D2  2  3  1  1
## D3  1  1  3  1
## D4  0  1  1  2
```

```r
diag(BC) &lt;- 0 # 대각값을 0으로 만든다. 
g_BC &lt;- as_tbl_graph(BC, directed = FALSE); par(mar = c(15,2,0,2))
plot(g_BC)
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-10-1.png" width="60%" /&gt;
---

- **edge 리스트(행렬 형태)**에서도 그래프 생성 가능 


```r
edge_list &lt;-  rbind(c("A","B"), c("B","A"), c("B","C"), c("C","A")) 
edge_list
```

```
##      [,1] [,2]
## [1,] "A"  "B" 
## [2,] "B"  "A" 
## [3,] "B"  "C" 
## [4,] "C"  "A"
```


```r
g &lt;- as_tbl_graph(edge_list, directed = FALSE)
par(mar=c(15,2,0,2))
plot(g)
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-12-1.png" width="70%" /&gt;
---
tidygraph의 오브젝트를 출력하면 표시되는 것 

```r
# 방금 전 edge list로 생성한 그래프 오브젝트
g
```

```
## # A tbl_graph: 3 nodes and 4 edges
## #
## # An undirected multigraph with 1 component
## #
## # Node Data: 3 x 1 (active)
##   name 
##   &lt;chr&gt;
## 1 A    
## 2 B    
## 3 C    
## #
## # Edge Data: 4 x 2
##    from    to
##   &lt;int&gt; &lt;int&gt;
## 1     1     2
## 2     1     2
## 3     2     3
## # … with 1 more row
```
- directed/undirected에 대한 것, node의 데이터프레임, edge의 데이터프레임 확인
- edge는 **from**, **to*** 칼럼으로 노드의 **sequence index**로 표시 

---
그래프 생성의 가장 기본은 edge list(+속성)로 구성된 데이터프레임, node list(+속성)로 구성된 데이터프레임으로부터 생성하는 방식임. 

- tidygraph는 tidyverse에서 데이터프레임을 관리하는 방식인 **tibble** 형태가 기본

- 그러나 base-R의 데이터프레임과 100% 호환되고, base-R에서 데이터프레임을 다루는 방식도 그대로 적용 가능 

- [data.table](http://r-datatable.com) 또한 자체 데이터프레임 형태인 **data.table**을 갖추고 있으며 base-R의 데이터프레임과 마찬가지로 100% 호환 


```r
node_df &lt;- data.frame(name = c("Hadley", "David", "Romain", "Julia"))
edge_df &lt;- data.frame(from = c(1, 1, 1, 2, 3, 3, 4, 4, 4),
                            to = c(2, 3, 4, 1, 1, 2, 1, 2, 3))
test_g &lt;- tbl_graph(nodes = node_df, edges = edge_df, directed = TRUE)
par(mar = c(20,2,0,2)) ; plot(test_g)
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-14-1.png" width="70%" /&gt;
---
class: inverse

### 연습문제 

* 지금까지 배운 그래프 오브젝트 생성 방법을 이용하여 아래와 같은 그림을 출력해 보세요.  


```r
 plot(g)
```
![:scale 80%](/pic/Bull.png)
---
class: inverse

### 연습문제 

* 앞서 생성한 bi-partite 네트워크의 그래프 오브젝트에서 노드의 **속성**을 찾고, 다른 그래프와의 차이점을 확인해 보세요.  
---
### 당연히 들어야 하는 의문 : link 정보의 **출처**

노드와 노드의 연결관계, 즉 링크/엣지리스트는 결코 공짜가 아님. 연결관계는 대부분 연결관계를 '뭉쳐 놓은' 곳에서 연결의 유형에 따라 **추출**⛏️해내야 하는 것임. 

발생할 수 있는 **연결의 유형**이란?

- **동시 출현(co-occurrence)** : 분석 단위 내에서 분석 대상 개체들이 함께 출현하는 것을 의미&lt;br&gt; 
    예 1) 문서 단위에서 **공저(co-author)** 관계로 발생하는 연구자, 연구기관, 섹터, 지역, 국가 등의 공존&lt;br&gt; 
    예 2) 문서 단위에서 **인지적 관계**로 발생하는 (저자)키워드, 학문분류코드 등의 공존&lt;br&gt;
    예 3) 앨범 단위에서 연주자 간 협연관계로 발생한 연주자 간 공존&lt;br&gt;
    예 4) 가족 단위에서 결혼관계에 의한 가문의 공존 등등&lt;br&gt; 

- **방향성 있는 상호 행위**  : 분석 대상 개체들의 방향성있는 행위로 발생하는 관계를 의미&lt;br&gt; 
    예 1) 문서 간의 인용 관계 (일방적)&lt;br&gt;
    예 2) 저널/연구기관/국가/분야 간의 인용 관계 (상호적)&lt;br&gt;
    예 3) 국가 간 교역 관계 (상호적)&lt;br&gt;
    예 4) 우정/애정 관계 등등&lt;br&gt;  



---

- **프로파일 기반 유사도** : 분석 대상 개체 간의 직접적 관계가 아니라, 별도의 특성을 기준으로 형성된 프로파일을 상호 비교하여 도출한 유사 관계를 의미&lt;br&gt;
    예 1) 연구자/연구기관/국가 등의 단위에서 형성한 연구분야/키워드 벡터의 유사성 비교&lt;br&gt; 
    예 2) 개체간 동시출현 관계에 대한 2차(second-order) 유사도 도출 
    

이와 별도로 두 개체 간의 직접적인 동시출현 관계는 보통 정규화 과정을 거치며, 

   ![:scale 55%](/pic/cooc_normalize.png)

Association Strength, Cosine, Inclusion, Jaccard 등의 유사도 지수 활용 (*Si*는 i개체의 총 출현빈도) 

---
프로파일 기반 유사도는 프로파일 벡터 간의 유사도를 측정하게 되며 대개 두 벡터 간의 Cosine을 측정 

  ![:scale 50%](/pic/cosine_formula.png)

- 개체의 갯수에 따라 비교해야할 개체의 쌍이 급격히 증가 (n*(n-1)/2)&lt;br&gt;
   개체가 1000개면 499,500 pairs &lt;br&gt;
   개체가 10000개면 49,995,000 pairs &lt;br&gt;
   
- 즉, 앞서 살펴본 tbl_graph 오브젝트를 생성한다고 할 때, node쪽 데이터프레임의 행(row) 갯수는 10000개여도, edge쪽의 데이터프레임 행(row) 갯수는 거의 5천만 개에 달하게 되는 것임. 


- 오늘 강의의 핵심은 각각의 연결 유형에 대해 링크를 생성하는 기법의 학습임. 

---
## 실존 서지 데이터 엿보기 

* Web of Science에서 개별 논문에 대해 각 분석 대상들이 **필드(field)**에 혼재되어 있는 모습 (예 : 김빛내리 교수 논문)


![:scale 110%](/pic/Vnarry_01.png)
---

* Co-occurrences, Directed relations, (Profile based) Similarity 등의 관계는 분석자가 정의한 **문서 집합**에서 **누적**된 값을 계산하여 추출   

![:scale 110%](/pic/Vnarry_02.png)
---
class: inverse, middle, center

### web of science  데이터에서 어떤 대상에 대하여 

### 어떠한 연결 관계를 추출하여 분석해보고 싶은지

### 각자 생각해봅시다. 

---
#### BC, CC에 대한 보론 

서지정보의 인용관계를 이용한 개체 간 유사도 산출에 활용되는 대표적인 기법이 **서지 결합(BC, Bibliographic Coupling)**과 **동시인용(CC, Co-citation)**이 있음. 

보통 **문서 간**의 인용 관계에 적용하나, 비교 대상 개체와 인용/피인용 프로파일 벡터를 구성하는 개체가 문서에 한정될 필요는 없음 (연구자/연구기관 등의 인용 관계 구성).

BC, CC는 앞서 **연결의 유형**에서 프로파일 기반의 유사도에 해당됨. 

* BC는 비교 대상 개체의 레퍼런스 프로파일 벡터(citing vector, backward-citation) 간 **중첩 빈도**로, CC는 비교 대상 개체의 피인용 프로파일 벡터(cited vector, forward-citation) 간의 **중첩 빈도**로 가정하면 됨. 
![:scale 85%](/pic/bc_cc_profile_scheme.png)

---
class: inverse, center, middle 
![:scale 18%](/pic/tidygraph_logo.png)
### 네트워크 데이터를 다루기 위해서는
### 근간을 이루는 
### 데이터프레임 형태의 데이터에 대한  
### 숙련된 처리 능력이 필요
![:scale 18%](/pic/datatable_logo.png)  ![:scale 18%](/pic/dplyr_logo.png) 

---
### [data.table](http://r-datatable.com) 패키지의 병행  

Python, R 두 진영에서 데이터 프레임 처리 속도와 효율에서 압도적인 성능(https://h2oai.github.io/db-benchmark/) 
![:scale 65%](/pic/datatable_bench.png)

tidyverse의 dplyr이 직관적이나 성능은 뒤쳐짐. data.table을 백엔드로 하고, dplyr의 문법을 적용할 수 있는 [dtplyr](https://cran.r-project.org/web/packages/dtplyr/index.html)도 등장하긴 하였으나, data.table의 직접 이용 적극 권장됨.  

---
### mtcars 데이터로 다시 돌아가서  
&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; mpg &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; cyl &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; disp &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; hp &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; drat &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; wt &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; qsec &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; vs &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; am &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; gear &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; carb &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Mazda RX4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 160 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 110 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.90 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.620 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 16.46 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Mazda RX4 Wag &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 160 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 110 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.90 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.875 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 17.02 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Datsun 710 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 22.8 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 108 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 93 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.85 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.320 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.61 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Hornet 4 Drive &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 258 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 110 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.08 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.215 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 19.44 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Hornet Sportabout &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.7 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 8 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 360 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 175 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.15 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.440 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 17.02 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Valiant &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 225 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 105 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.76 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.460 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 20.22 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

base-R, dplyr, data.table 세가지 방식을 확인 


```r
# 우선 mpg 변수(column)를 개별 벡터로 추출하는 방법 
# base-R
mtcars[["mpg"]]; mtcars$mpg; mtcars[, 1]
# dplyr
library(dplyr)
mtcars %&gt;% pull(mpg)
# data.table
library(data.table)
mtcars &lt;- as.data.table(mtcars)
mtcars[, mpg]
```

---
### 변수의 조작 

**dplyr**
* mutate : 기존 변수에 함수를 적용하여 새로운 변수의 생성 
* select : 데이터프레임에서 변수를 선택 
* filter : 조건을 만족하는 값을 갖는 행(row)을 선별 
* summarise : 여러 값을 일정 기준과 함수에 따라 하나의 값으로 축소 
* arrange : 행을 정렬 
* group_by : 위 모든 조작은 특정 변수에 존재하는 '그룹'별로 적용    

**data.table**
* 형태 : **dt[i, j, by]**
* dt라는 데이터프레임에서 
* by에서 지정한 변수의 그룹에 따라 (옵션)
* i에서 지정한 조건의 행을 선별 (옵션)
* j에서 지정한 변수에 함수를 적용 
* j는 기존 데이터프레임 내에서 업데이트되거나 (:=), 
* 새로운 데이터프레임을 생성(.())
---
#### 반드시 숙련된 조작 능력을 위한 지속/반복 학습 필요  

dplyr, data.table 둘 다 잘 정리된 cheatsheet, vignette이 존재  
오늘 강의에서는 두 패키지의 차이를 확인하는 위주의 예제를 몇가지 진행 


```r
# dplyr 
library(dplyr)
starwars %&gt;% # 슬라이드 표시를 위해 첫 3행과 1~5번째 칼럼만 출력 
  filter(species == "Droid") %&gt;% head(3) %&gt;% select(1:5)
```

```
## # A tibble: 3 x 5
##   name  height  mass hair_color skin_color 
##   &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      
## 1 C-3PO    167    75 &lt;NA&gt;       gold       
## 2 R2-D2     96    32 &lt;NA&gt;       white, blue
## 3 R5-D4     97    32 &lt;NA&gt;       white, red
```


```r
# data.table
library(data.table)
star_dt &lt;- as.data.table(starwars) # 또는 setDT(mtcars)
star_dt[species == "Droid"][1:3, 1:5]
```

```
##     name height mass hair_color  skin_color
## 1: C-3PO    167   75       &lt;NA&gt;        gold
## 2: R2-D2     96   32       &lt;NA&gt; white, blue
## 3: R5-D4     97   32       &lt;NA&gt;  white, red
```

---
#### 하나하나 비교해 보기 


```r
# dplyr : regular expression 
starwars %&gt;% 
  select(name, ends_with("color")) %&gt;% head(3)
```

```
## # A tibble: 3 x 4
##   name           hair_color skin_color  eye_color
##   &lt;chr&gt;          &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;    
## 1 Luke Skywalker blond      fair        blue     
## 2 C-3PO          &lt;NA&gt;       gold        yellow   
## 3 R2-D2          &lt;NA&gt;       white, blue red
```


```r
# data.table : regular expression 
# SD = Subset of Data
star_dt[, .SD, .SDcols = patterns("color$")][1:3, ]
```

```
##    hair_color  skin_color eye_color
## 1:      blond        fair      blue
## 2:       &lt;NA&gt;        gold    yellow
## 3:       &lt;NA&gt; white, blue       red
```
---
#### 새로운 변수 생성하기 

```r
# dplyr : mutate 
starwars %&gt;% 
  mutate(bmi = mass / ((height / 100)  ^ 2)) %&gt;%
  select(name:mass, bmi) %&gt;% head(3)
```

```
## # A tibble: 3 x 4
##   name           height  mass   bmi
##   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 Luke Skywalker    172    77  26.0
## 2 C-3PO             167    75  26.9
## 3 R2-D2              96    32  34.7
```


```r
# data.table : update ':='
star_dt[, bmi := mass / ((height / 100) ^2)][1:3, .(1:3, 14)]
```

```
##    V1 V2
## 1:  1 14
## 2:  2 14
## 3:  3 14
```
---
#### 데이터 정렬 


```r
# dplyr : arrange + desc  
starwars %&gt;% 
  arrange(desc(mass)) %&gt;% 
  head(3) %&gt;% select(1:5)
```

```
## # A tibble: 3 x 5
##   name                  height  mass hair_color skin_color      
##   &lt;chr&gt;                  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           
## 1 Jabba Desilijic Tiure    175  1358 &lt;NA&gt;       green-tan, brown
## 2 Grievous                 216   159 none       brown, white    
## 3 IG-88                    200   140 none       metal
```


```r
# data.table : order + -  
star_dt[order(-mass), ][1:3, 1:5]
```

```
##                     name height mass hair_color       skin_color
## 1: Jabba Desilijic Tiure    175 1358       &lt;NA&gt; green-tan, brown
## 2:              Grievous    216  159       none     brown, white
## 3:                 IG-88    200  140       none            metal
```

---
#### 그룹 기준의 복합 연산 


```r
# dplyr : group_by + summarise  
starwars %&gt;%
  group_by(species) %&gt;%
  summarise(
    n = n(),
    mass = mean(mass, na.rm = TRUE)
  ) %&gt;%  filter(n &gt; 1, mass &gt; 50) %&gt;% arrange(desc(n)) %&gt;% head(4) 
```

```
## # A tibble: 4 x 3
##   species      n  mass
##   &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;
## 1 Human       35  82.8
## 2 Droid        5  69.8
## 3 Gungan       3  74  
## 4 Kaminoan     2  88
```


```r
# data.table : by + list(== .())  
star_dt[, .(n = .N, 
          mass = mean(mass, na.rm  = TRUE)), 
        by = .(species)][n &gt; 1 &amp; mass &gt; 50, ][order(-n),][1:4, ]
```

```
##    species  n      mass
## 1:   Human 35  82.78182
## 2:   Droid  5  69.75000
## 3:  Gungan  3  74.00000
## 4: Wookiee  2 124.00000
```
---
class: inverse

#### 연습문제 

* mtcars 데이터에서 기어 단수(gear)에 따른 평균 연비(mpg)를 'avg_mpg' 변수로 생성하고, 결과를 평균 연비의 내림차순으로 정리해 보세요.  

* 위 문제에서 기어 단수(gear) 기준과와 자동/수동변속기 여부(am, 0은 자동 1은 수동) 기준을 결합하여 평균 연비를 계산하고 평균 연비의 내림차순으로 정리해 보세요. 

* iris 데이터에서 Species 변수 (3개 종류)를 기준으로 Sepal.Length, Sepal.Width, Petal.Length, Petal.Width 변수의 평균값을 구해보세요. 
  (힌트 : dplyr은 summarise_at, data.table은 lapply와 .SD의 조합)

---

class: inverse, middle, center

### 네트워크 시각화를 위한 ggraph은 
![](/pic/ggraph_logo.png)
### ggplot2과 연동 + 문법 그대로 이용 
![:scale 18%](/pic/ggplot2_logo.png)
### ggplot2의 활용능력은? 
---
##### ggplot
.pull-left[
ggplot2는 그래프의 요소들을 레이어(layer)화하고, 이를 결합하는 매우 체계적인 문법구조를 갖추고 있음. 

![:scale 72%](/pic/ggplot_scheme_01.png)]
.pull-right[![:scale 75%](/pic/ggplot_scheme_02.png)]
---
#### gapminder 데이터 시각화 

```r
library(ggplot2)
library(gapminder)
# mapping에는 그래프에서 변수의 값에 따라 변동을 부여하는 요소 
p &lt;- ggplot(data = gapminder, 
            mapping = aes(x = gdpPercap, y=lifeExp))
# 산점도 그래프 적용 + 스무딩 적용 
p + geom_point() + geom_smooth()
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-28-1.png" width="50%" /&gt;
---
#### 조금 더 산뜻하게 꾸미기  

```r
p + geom_point(alpha = 0.3) + # alpha는 투명도 
    geom_smooth(method = "gam") + # generalized additive model 스무딩 
    scale_x_log10(labels = scales::dollar) + # 로그 축으로 변경 
    labs(x = "GDP Per Capita", y = "Life Expectancy in Years",
         title = "Economic Growth and Life Expectancy",
         subtitle = "Data points are country-years",
         caption = "Source: Gapminder.")
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-29-1.png" width="50%" /&gt;
---
#### 빠져 있는 요소 탐색 

```r
p &lt;- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp,
                          color = continent, # 대륙별 편차 
                          fill = continent)) # fill도 연동 (에러바 색 보정) 
p + geom_point() +
    geom_smooth(method = "loess") +
    scale_x_log10()
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-30-1.png" width="48%" /&gt;
---
#### ggplot에 맞는 데이터 형태 변환 
일상에서 마주치는 데이터 형태는 "wide" 형태가 더 많음. 이를 테면 남자, 여자를 별도의 칼럼(변수)으로 집어 넣는 것임. 이런 구조에서는 남자 그래프 따로, 여자 그래프 때로 만들 수밖에 없음. 

만약 남자 여자를 '젠더'라는 변수에서 "long" 형태로 하여 데이터를 만들었다면, ggplot의 `mapping=aes(colour = gender)` 이런 방식으로 한 그래프 내에서 둘을 분리하여 표시하는 것이 가능해짐.   

이러한 문제에 대한 해결 방식을 제시하기 위해 아래와 같은 가상 데이터 생성 

```r
dt &lt;- data.table(year = 2000:2019 ,
                 math_woman = 65:84*(1+rnorm(20,0,0.05)),
                 kor_woman = 75:94*(1+rnorm(20,0,0.05)))
head(dt, 4)
```

```
##    year math_woman kor_woman
## 1: 2000   66.75162  72.69015
## 2: 2001   69.40171  78.50991
## 3: 2002   68.89585  73.00883
## 4: 2003   67.94095  75.73458
```
---
와이드 형태에서는 년도별로 각 칼럼의 값을 보여주는 방식만 가능 

```r
ggplot(dt, mapping = aes(x = year, y = math_woman)) +
  geom_line() + geom_point(color = "steelblue") +
  geom_smooth()
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-32-1.png" width="40%" /&gt;

---
#### 롱타입 변환은 data.table::melt함수로 

```r
# 위 데이터는 id.vars는 고유 키값을, 
# measure.vars 는 유형을 묶어서(=롱타입으로 하여) 값을 부여 
# variable.name 은 묶어서 생성된 새 변수 이름. 
# value.name은 지정하지 않으면 자동으로 "value"라는 컬럼 부여 
dt_melt &lt;- melt(dt, id.vars = 1, 
                measure.vars = c("math_woman", "kor_woman"),
                variable.name = "subject", 
                value.name = "score")
head(dt_melt, 10)
```

```
##     year    subject    score
##  1: 2000 math_woman 66.75162
##  2: 2001 math_woman 69.40171
##  3: 2002 math_woman 68.89585
##  4: 2003 math_woman 67.94095
##  5: 2004 math_woman 69.94414
##  6: 2005 math_woman 71.66124
##  7: 2006 math_woman 69.80130
##  8: 2007 math_woman 77.75905
##  9: 2008 math_woman 71.38101
## 10: 2009 math_woman 67.48954
```

---
#### 롱타입 데이터가 ggplot에서 적용되면 

```r
ggplot(dt_melt, aes(x = year, y = score, color = subject)) + 
  geom_line() + geom_point()
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-34-1.png" width="60%" /&gt;



---
#### 조금 더 어려운 복합 wide 형태 


```r
dt &lt;- data.table(year = 2000:2019 ,
                 math_woman = 65:84*(1+rnorm(20,0,0.05)),
                 kor_woman = 75:94*(1+rnorm(20,0,0.05)),
                 math_man = 70:89*(1+rnorm(20,0,0.05)),
                 kor_man = 65:84*(1+rnorm(20,0,0.05)))
head(dt, 4)
```

```
##    year math_woman kor_woman math_man  kor_man
## 1: 2000   68.07563  75.53303 67.09133 65.16551
## 2: 2001   69.70449  77.39848 77.62002 63.98647
## 3: 2002   69.25154  78.43216 72.15817 67.31316
## 4: 2003   67.57296  79.29590 72.71578 59.62126
```

```r
# 이 경우에는 두 번에 걸쳐 나누어 long 타입 변환 
dt_melt &lt;- melt(dt, id.vars = 1, 
                measure.vars = list(c("math_woman", "math_man"),
                                    c("kor_woman", "kor_man")),
                variable.name = "gender",
                value.name = c("math", "kor"))
head(dt_melt, 4)
```

```
##    year gender     math      kor
## 1: 2000      1 68.07563 75.53303
## 2: 2001      1 69.70449 77.39848
## 3: 2002      1 69.25154 78.43216
## 4: 2003      1 67.57296 79.29590
```
---
#### 두번째 롱타입 변환 

```r
dt_melt[, gender := factor(gender, levels = 1:2, labels = c("F", "M"))]
dt_melt2 &lt;- melt(dt_melt, id.vars = 1:2, measure.vars = 3:4, 
                 variable.name = "subject",
                 value.name = "score")
head(dt_melt2, 4)
```

```
##    year gender subject    score
## 1: 2000      F    math 68.07563
## 2: 2001      F    math 69.70449
## 3: 2002      F    math 69.25154
## 4: 2003      F    math 67.57296
```

---
#### facet으로 구분 

```r
ggplot(dt_melt2, aes(x = year, y = score, 
                     color = subject)) + 
  geom_line() + geom_point() + facet_wrap(~gender)
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-38-1.png" width="50%" /&gt;

```r
# 한글 처리 + 라벨/레전드/사용자색상 변경, 
# 파일 저장 등의 나용은 내일 강의에 포함   
```

---
class: inverse

####  연습문제 

* mtcars데이터를 가지고, 기어단수(gear)별로 x축에 무게(wt), y축에 연비(mpg)를 산점도로 표시하고, 스무딩 곡선을 추가해서 나타내어 보여주세요. 기어단수별 구분을 어떻게 표현할 지에 대해 나름대로 고민해 보세요. 


* iris데이터는 세가지 종에 대해 Sepal.Length, Sepal.Width, Petal.Length, Petal.Width 4가지 들어 있다. 이 4가지 변수를 Length와 Width를 "type"이라는 이름의 변수로 하여 long type을 만들고, 아래 그림을 생성해 보세요.  

  ![:scale 70%](/pic/iris_exercise.png)

---
class: inverse, middle, center

## 네트워크 연결 관계 추출 

---
### 동시 출현(co-occurrence) 빈도 구하기  

5장의 (가상의) 재즈 음반에서 연주자들의 협연 빈도를 추출해보자. 보통 하나의 row 단위에서 동시 출현은 하나의 필드에 구분자(separator)로 묶여 있게 된다. Web of Science의 데이터를 받게 되면, row 하나는 문헌에 해당하고 동시 출현 관계가 존재하는 단위는 칼럼(=필드)에 해당한다.


```r
dt &lt;- data.table(rec = 1:5, 
   musician = c("John Coltrane;McCoy Tyner;Reggie Workman;Elvin Jones",
              "John Coltrane;Miles Davis;Ron Carter;Herbie Hancock",
              "Miles Davis;Wayne Shorter;Ron Carter;Elvin Jones",
              "Wayne Shorter;McCoy Tyner;Reggie Workman;Elvin Jones",
              "Joe Henderson;McCoy Tyner;Ron Carter;Al Foster"))
dt
```

```
##    rec                                             musician
## 1:   1 John Coltrane;McCoy Tyner;Reggie Workman;Elvin Jones
## 2:   2  John Coltrane;Miles Davis;Ron Carter;Herbie Hancock
## 3:   3     Miles Davis;Wayne Shorter;Ron Carter;Elvin Jones
## 4:   4 Wayne Shorter;McCoy Tyner;Reggie Workman;Elvin Jones
## 5:   5       Joe Henderson;McCoy Tyner;Ron Carter;Al Foster
```

---
### data.table 방식 
구분자를 기준으로 문자 스트링을 구분하면 반환되는 값은 **리스트** 이다. 따라서 이를 **unlist** 함수를 적용하여 **벡터**로 만든다. 이 작업을 각 음반(레코드)를 기준으로 수행한다. 이에 해당하는 것이 아래 코드이다. 


```r
dt_long &lt;- dt[, 
      .(musician = unlist(strsplit(musician, ";"))), 
      by = .(rec)]
head(dt_long, 6)
```

```
##    rec       musician
## 1:   1  John Coltrane
## 2:   1    McCoy Tyner
## 3:   1 Reggie Workman
## 4:   1    Elvin Jones
## 5:   2  John Coltrane
## 6:   2    Miles Davis
```
그 다음에는 롱 타입으로 쪼개 놓은 것을 다시 레코드 기준으로, pair 쌍을 만들어야 한다. 앞서 그래프 오브젝트를 만들 때 edge의 데이터 프레임이 from 칼럼, to 칼럼으로 되어 있었던 것을 기억해보자. 그러한 형태를 만는 것이 목표다.
---
pair 쌍을 만드는 것을 함수로 만들어 두면 적용할 때 편리하다.  

```r
pair_construct &lt;- function(x) {
  x &lt;- sort(unique(x)) # 정렬 
  if (length(x) ==1) return(
    data.table(V1 = x, V2 = x) # 솔로 음반이면 본인 것만 pair list 생성하자.   
  )
  temp_mat &lt;- combn(x, 2) # combn 은 조합하여 행렬로 반환한다.  
  temp_dt &lt;- as.data.table(t(temp_mat))
  return(temp_dt)
}
```

```r
# combn함수의 반환 결과를 확인해보자 
combn(c("A","B","C"), 2)
```

```
##      [,1] [,2] [,3]
## [1,] "A"  "A"  "B" 
## [2,] "B"  "C"  "C"
```

```r
# 전치행렬로 바꾸면 앞에서 보았던 edge list 행렬 형태가 나타난다.  
t(combn(c("A","B","C"), 2))
```

```
##      [,1] [,2]
## [1,] "A"  "B" 
## [2,] "A"  "C" 
## [3,] "B"  "C"
```

---
만들어 둔 함수를 레코드 기준으로 적용한다. 

```r
dt_pair &lt;- dt_long[, pair_construct(musician), by = .(rec)]
dt_pair[, weight := 1L] # weight 칼럼을 생성하여 일단 1을 부여
```


```r
# pair를 기준으로 weight를 합한다. 
dt_cooc_link &lt;- dt_pair[, .(weight = sum(weight)),
                        by = .(V1, V2)]
head(dt_cooc_link, 10)
```

```
##                 V1             V2 weight
##  1:    Elvin Jones  John Coltrane      1
##  2:    Elvin Jones    McCoy Tyner      2
##  3:    Elvin Jones Reggie Workman      2
##  4:  John Coltrane    McCoy Tyner      1
##  5:  John Coltrane Reggie Workman      1
##  6:    McCoy Tyner Reggie Workman      2
##  7: Herbie Hancock  John Coltrane      1
##  8: Herbie Hancock    Miles Davis      1
##  9: Herbie Hancock     Ron Carter      1
## 10:  John Coltrane    Miles Davis      1
```
---
 그래프 오브젝트로 만든다음, ggraph는 아직 배우지 않았으므로 아쉽지만 igraph의 기본 함수로 시각화를 해본다. 

```r
g &lt;- as_tbl_graph(dt_cooc_link, directed = FALSE)
plot(g, width = TRUE, edge.width = edge_attr(g)$weight)
```

![](network_course_part01_files/figure-html/unnamed-chunk-46-1.png)&lt;!-- --&gt;
 
---
### dplyr 방식 

레코드 단위로 구분자 기준으로 나누어 주는 방식이 data.table과 약간 차이가 나게 된다. 


```r
library(tidyr)
library(purrr)
dt_long &lt;- dt %&gt;% 
  group_by(rec) %&gt;% 
  mutate(musician = strsplit(musician, ";")) %&gt;% # cell에 리스트가 들어간다.
  unnest(cols = musician) # tidyr::unnest는 리스트 셀을 풀어준다. 
head(dt_long, 8)
```

```
## # A tibble: 8 x 2
## # Groups:   rec [2]
##     rec musician      
##   &lt;int&gt; &lt;chr&gt;         
## 1     1 John Coltrane 
## 2     1 McCoy Tyner   
## 3     1 Reggie Workman
## 4     1 Elvin Jones   
## 5     2 John Coltrane 
## 6     2 Miles Davis   
## 7     2 Ron Carter    
## 8     2 Herbie Hancock
```

---
#### apply 함수의 tidyverse 버전인 purrr::map함수 적용 

```r
dt_pair2 &lt;- dt_long %&gt;%
  group_by(rec) %&gt;% 
  split(.$rec) %&gt;% # split으로 레코드 단위가 한 요소인 리스트를 생성
  map(., function(x) pair_construct(x$musician)) %&gt;% # 
  bind_rows(.id = "rec") # 리스트 안에 들어 있는 데이터프레임을 결합 
head(dt_pair2, 5)
```

```
##    rec            V1             V2
## 1:   1   Elvin Jones  John Coltrane
## 2:   1   Elvin Jones    McCoy Tyner
## 3:   1   Elvin Jones Reggie Workman
## 4:   1 John Coltrane    McCoy Tyner
## 5:   1 John Coltrane Reggie Workman
```
이후 과정은 동일 


```r
dt_pair_fin &lt;- dt_pair2 %&gt;% mutate(weight = 1) %&gt;% 
  group_by(V1, V2) %&gt;% summarise(weight = sum(weight))
head(dt_pair_fin, 4)
```

```
## # A tibble: 4 x 3
## # Groups:   V1 [2]
##   V1          V2            weight
##   &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt;
## 1 Al Foster   Joe Henderson      1
## 2 Al Foster   McCoy Tyner        1
## 3 Al Foster   Ron Carter         1
## 4 Elvin Jones John Coltrane      1
```

---
dplyr 버전에서도 그래프 오브젝트로 만든다음, 역시 igraph를 이용해 확인한다. 

```r
g &lt;- as_tbl_graph(dt_pair_fin, directed = FALSE)
plot(g, width = TRUE, edge.width = edge_attr(g)$weight)
```

&lt;img src="network_course_part01_files/figure-html/unnamed-chunk-50-1.png" width="70%" /&gt;

---
### Matrix 방식 
이 방식은 co-occurrence 링크인 경우도 적용가능하지만, 프로파일 벡터 간의 유사도를 계산하기 위해 필요한 기법임. 

먼저 musician(행) x record(열)인 행렬을 생성할 것임. 

```r
# 앞에서 생성한 dt_long부터 시작 
row_name &lt;- unique(dt_long$musician)
column_name &lt;- unique(dt_long$rec)
row_id &lt;- match(dt_long$musician, row_name) # 인덱스 번호 추출 
column_id &lt;- match(dt_long$rec, column_name) # sparse matrix 생성에 필요
```


```r
library(Matrix)
# Matrix패키지의 sparse matrix 생성 
mat_sparse &lt;- sparseMatrix(i = row_id,
                           j = column_id,
                           x = 1L,
                           dimnames = list(
                             row_name, 
                             column_name))
```
---
sparse matrix 오브젝트가 성능과 메모리 관리에 훨씬 효율적임. 


```r
mat_res &lt;- mat_sparse %*% t(mat_sparse) # 행렬 곱을 한다
mat_res2 &lt;- triu(mat_res, k = 1) # 대칭이므로, 대각값을 포함하여 하삼각을 제외
mat_fin &lt;- summary(mat_res2) # summary 함수로 pair 리스트를 받는다
head(mat_fin, 10) # 인덱스 번호로 반환
```

```
## 10 x 10 sparse Matrix of class "dtCMatrix", with 25 entries 
##    i j x
## 1  1 2 1
## 2  1 3 1
## 3  2 3 2
## 4  1 4 1
## 5  2 4 2
## 6  3 4 2
## 7  1 5 1
## 8  4 5 1
## 9  1 6 1
## 10 2 6 1
```

sparse matrix 자체를 입력값으로 하여 행 기준(위 사례)의 pair쌍에 대해 유사도를 계산할 수 있음 (프로파일 기반 유사도 링크). 

`text2vec::sim2(m_sparse, method = "cosine", norm = "l2")`
---
결과로 받은 인덱스 번호를 앞에서 만들어 둔 이름 벡터에 집어 넣어 다시 이름을 반환하는 방식으로 최종 원하는 데이터프레임을 생성한다.


```r
df &lt;- data.frame(from = row_name[mat_fin$i],
                 to = row_name[mat_fin$j],
                 weight = mat_fin$x)
g &lt;- as_tbl_graph(df, directed = FALSE)
plot(g)
```

![](network_course_part01_files/figure-html/unnamed-chunk-54-1.png)&lt;!-- --&gt;
---
class: inverse
### 연습문제 

* 다음 데이터프레임에서 국가 간 협력연구 네트워크를 도출하고, 시각화까지 해보세요.
  협력 연구가 아니라 단일 국가의 논문이 존재합니다. 이에 대한 처리에 조금 신경쓰셔야 합니다. 
  

```r
wos &lt;- data.frame(UT = 1:10,
                       country = c("South Korea", "USA;Japan", "Japan;Germany",
                                   "South Korea;USA;Germany", "Germany", 
                                   "USA;Germany", "Japan;France;Germany",
                                   "France;Germany", "USA;South Korea", "USA"))
```

---
class: inverse

# 내일은 

* tidygraph, ggraph의 기초 문법 

* 데이터의 반입(import), 반출(export) 기법 

* tidygraph, ggraph를 이용한 (중고급) 데이터 처리 기법

* Web of Science 실제 데이터 처리 실습  

* 서지데이터 보완을 위한 crossref API 이용 맛보기

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
